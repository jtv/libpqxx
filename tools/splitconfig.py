#! /usr/bin/env python3

"""Extract configuration items into various configuration headers.

This uses the configitems file, a database consisting of text lines with these
whitespace-separated fields:

* Name of the configuration item, e.g. `PQXX_HAVE_PTRDIFF_T`.
* The environmental factor determining the item, e.g. autotools or compiler.
"""

from argparse import ArgumentParser
from errno import ENOENT
import os.path
from os import getcwd
import re
from sys import (
    getdefaultencoding,
    getfilesystemencoding,
    stdout,
    )


class Fail(Exception):
    """User-presentable exception, no traceback needed."""


def guess_fs_encoding():
    """Try to establish the filesystem encoding.

    It's a sad thing: some guesswork is involved.  The encoding often seems to
    be conservatively, and incorrectly, set to ascii.
    """
    candidates = [
        getfilesystemencoding(),
        getdefaultencoding(),
        'utf-8',
        ]
    for encoding in candidates:
        if encoding.lower() not in ('ascii', 'ansi_x3.4-1968'):
            return encoding
    raise AssertionError("unreachable code reached.")


def guess_output_encoding():
    """Return the encoding of standard output."""
    # Apparently builds in Docker containers may have None as an encoding.
    # Fall back to ASCII.  If this ever happens in a non-ASCII path, well,
    # there may be a more difficult decision to be made.  We'll burn that
    # bridge when we get to it, as they almost say.
    return stdout.encoding or 'ascii'


def decode_path(path):
    """Decode a path element from bytes to unicode string."""
    return path.decode(guess_fs_encoding())


def encode_path(path):
    """Encode a path element from unicode string to bytes."""
    # Nasty detail: unicode strings are stored as UTF-16.  Which can contain
    # surrogate pairs.  And those break in encoding, unless you use this
    # special error handler.
    return path.encode(guess_fs_encoding(), 'surrogateescape')


def read_text_file(path, encoding='utf-8'):
    """Read text file, return as string, or `None` if file is not there."""
    assert isinstance(path, type(''))
    try:
        with open(encode_path(path), encoding=encoding) as stream:
            return stream.read()
    except IOError as error:
        if error.errno == ENOENT:
            return None
        else:
            raise


def read_lines(path, encoding='utf-8'):
    """Read text file, return as list of lines."""
    assert isinstance(path, type(''))
    with open(encode_path(path), encoding=encoding) as stream:
        return list(stream)


def read_configitems(filename):
    """Read the configuration-items database.

    :param filename: Path to the configitems file.
    :return: Sequence of text lines from configitems file.
    """
    return [line.split() for line in read_lines(filename)]


def map_configitems(items):
    """Map each config item to factor.

    :param items: Sequence of config items: (name, factor).
    :return: Dict mapping each item name to a factor.
    """
    return {
        item: factor
        for item, factor in items
        }


def read_header(source_tree, filename):
    """Read the original config.h generated by autoconf.

    :param source_tree: Path to libpqxx source tree.
    :param filename: Path to the config.h file.
    :return: Sequence of text lines from config.h.
    """
    assert isinstance(source_tree, type(''))
    assert isinstance(filename, type(''))
    return read_lines(os.path.join(source_tree, filename))


def extract_macro_name(config_line):
    """Extract a cpp macro name from a configuration line.

    :param config_line: Text line from config.h which may define a macro.
    :return: Name of macro defined in `config_line` if it is a `#define`
        statement, or None.
    """
    config_line = config_line.strip()
    match = re.match(r'\s*#\s*define\s+([^\s]+)', config_line)
    if match is None:
        return None
    else:
        return match.group(1)


def extract_section(header_lines, items, factor):
    """Extract config items for given factor from header lines.

    :param header_lines: Sequence of header lines from config.h.
    :param items: Dict mapping macro names to factors.
    :param factor: Extract only macros for this environmental factor.
    :return: Sequence of `#define` lines from `header_lines` insofar they
        fall within the requested section.
    """
    return sorted(
        line.strip()
        for line in header_lines
        if items.get(extract_macro_name(line)) == factor
        )


def compose_header(lines, factor):
    """Generate header text containing given lines."""
    intro = f"/* Automatically generated from config.h: {factor} config. */"
    return '\n'.join([intro, ''] + lines + [''])


def generate_config(source_tree, header_lines, items, factor):
    """Generate config file for a given section, if appropriate.

    Writes nothing if the configuration file ends up identical to one that's
    already there.

    :param source_tree: Location of the libpqxx source tree.
    :param header_lines: Sequence of header lines from config.h.
    :param items: Dict mapping macro names to factor.
    :param factor: Extract only macros for this environmental factor.
    """
    assert isinstance(source_tree, type(''))
    config_file = os.path.join(
        source_tree, 'include', 'pqxx', f'config-{factor}.h')
    unicode_path = config_file.encode(guess_output_encoding(), 'replace')
    section = extract_section(header_lines, items, factor)
    contents = compose_header(section, factor)
    if read_text_file(config_file) == contents:
        print(f"Generating {unicode_path}: no changes--skipping.")
        return

    print(f"Generating {unicode_path}: {len(section)} item(s).")
    path = encode_path(config_file)
    with open(path, 'w', encoding='ascii', newline='\n') as header:
        header.write(contents)


def parse_args():
    """Parse command-line arguments."""
    default_source_tree = os.path.dirname(
        os.path.dirname(os.path.normpath(os.path.abspath(__file__))))
    parser = ArgumentParser(description=__doc__)
    parser.add_argument(
        'sourcetree', metavar='PATH', default=default_source_tree,
        help="Location of libpqxx source tree.  Defaults to '%(default)s'.")
    return parser.parse_args()


def check_args(args):
    """Validate command-line arguments."""
    if not os.path.isdir(args.sourcetree):
        raise Fail(f"Not a directory: '{args.sourcetree}'.")


def get_current_dir():
    cwd = getcwd()
    if isinstance(cwd, bytes):
        return decode_path(cwd)
    else:
        return cwd


def main():
    """Main program entry point."""
    args = parse_args()
    check_args(args)
    # The configitems file is under revision control; it's in sourcetree.
    items = read_configitems(os.path.join(args.sourcetree, 'configitems'))
    factors = sorted(set(item[1] for item in items))
    # The config.h header is generated; it's in the build tree, which should
    # be where we are.
    directory = get_current_dir()
    original_header = read_header(
        directory,
        os.path.join('include', 'pqxx', 'config.h'))
    items_map = map_configitems(items)

    for factor in factors:
        generate_config(directory, original_header, items_map, factor)


if __name__ == '__main__':
    main()
